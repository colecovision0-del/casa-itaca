import {
  BaseExtension,
  BaseInstrumentation,
  BaseTransport,
  ConsoleInstrumentation,
  ConsoleTransport,
  Conventions,
  EVENT_ROUTE_CHANGE,
  ErrorsInstrumentation,
  FetchTransport,
  InternalLoggerLevel,
  LogLevel,
  TransportItemType,
  VERSION,
  ViewInstrumentation,
  WebVitalsInstrumentation,
  allLogLevels,
  browserMeta,
  buildStackFrame,
  createInternalLogger,
  createPromiseBuffer,
  createSession,
  deepEqual,
  defaultEventDomain,
  defaultExceptionType,
  defaultGlobalObjectKey,
  defaultInternalLoggerLevel,
  defaultLogLevel,
  faro,
  genShortID,
  getCurrentTimestamp,
  getDataFromSafariExtensions,
  getInternalFromGlobalObject,
  getStackFramesFromError,
  getTransportBody,
  getWebInstrumentations,
  globalObject,
  initializeFaro,
  internalGlobalObjectKey,
  isArray,
  isBoolean,
  isDomError,
  isDomException,
  isElement,
  isElementDefined,
  isError,
  isErrorDefined,
  isErrorEvent,
  isEvent,
  isEventDefined,
  isFunction,
  isInstanceOf,
  isInt,
  isInternalFaroOnGlobalObject,
  isMap,
  isMapDefined,
  isNull,
  isNumber,
  isObject,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isSyntheticEvent,
  isThenable,
  isToString,
  isTypeof,
  isUndefined,
  makeCoreConfig,
  noop,
  parseStacktrace,
  setInternalFaroOnGlobalObject,
  transportItemTypeToBodyKey,
  unknownString,
  userActionDataAttribute
} from "./chunk-EMYTMRSW.js";
import {
  require_jsx_runtime
} from "./chunk-CRNJR6QK.js";
import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  __commonJS,
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics5(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics5(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics5;
  }
});

// node_modules/@grafana/faro-react/dist/esm/errorBoundary/const.js
var faroErrorBoundaryInitialState = {
  hasError: false,
  error: null
};

// node_modules/@grafana/faro-react/dist/esm/errorBoundary/FaroErrorBoundary.js
var import_react2 = __toESM(require_react());

// node_modules/@grafana/faro-react/dist/esm/dependencies.js
var internalLogger;
var api;
function setDependencies(newInternalLogger, newApi) {
  internalLogger = newInternalLogger;
  api = newApi;
}

// node_modules/@grafana/faro-react/dist/esm/utils/reactVersion.js
var import_react = __toESM(require_react());
var reactVersion = import_react.version;
var reactVersionMajor = getMajorReactVersion();
var isReactVersionAtLeast18 = isReactVersionAtLeast(18);
var isReactVersionAtLeast17 = isReactVersionAtLeast(17);
var isReactVersionAtLeast16 = isReactVersionAtLeast(16);
function getMajorReactVersion() {
  const major = reactVersion.split(".");
  try {
    return major[0] ? parseInt(major[0], 10) : null;
  } catch (err) {
    return null;
  }
}
function isReactVersionAtLeast(version2) {
  return reactVersionMajor === null ? false : reactVersionMajor >= version2;
}

// node_modules/@grafana/faro-react/dist/esm/errorBoundary/FaroErrorBoundary.js
var FaroErrorBoundary = class extends import_react2.Component {
  constructor(props) {
    super(props);
    this.state = faroErrorBoundaryInitialState;
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
  }
  getErrorWithComponentStack(error, errorInfo) {
    if (!isReactVersionAtLeast17 || !errorInfo.componentStack) {
      return error;
    }
    const newError = new Error(error.message);
    newError.name = `React ErrorBoundary ${error.name}`;
    newError.stack = errorInfo.componentStack;
    return newError;
  }
  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    var _a, _b, _c, _d;
    const errorWithComponentStack = this.getErrorWithComponentStack(error, errorInfo);
    (_b = (_a = this.props).beforeCapture) === null || _b === void 0 ? void 0 : _b.call(_a, errorWithComponentStack);
    api.pushError(errorWithComponentStack, this.props.pushErrorOptions);
    (_d = (_c = this.props).onError) === null || _d === void 0 ? void 0 : _d.call(_c, errorWithComponentStack);
    this.setState({ hasError: true, error });
  }
  componentDidMount() {
    var _a, _b;
    (_b = (_a = this.props).onMount) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).onUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.error);
  }
  resetErrorBoundary() {
    var _a, _b;
    (_b = (_a = this.props).onReset) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.error);
    this.setState(faroErrorBoundaryInitialState);
  }
  render() {
    if (!this.state.hasError) {
      return isFunction(this.props.children) ? this.props.children() : this.props.children;
    }
    const element = !isFunction(this.props.fallback) ? this.props.fallback : this.props.fallback(this.state.error, this.resetErrorBoundary);
    if ((0, import_react2.isValidElement)(element)) {
      return element;
    }
    if (this.props.fallback) {
      internalLogger === null || internalLogger === void 0 ? void 0 : internalLogger.warn("ErrorBoundary\n", 'Cannot get a valid ReactElement from "fallback"');
    }
    return null;
  }
};

// node_modules/@grafana/faro-react/dist/esm/errorBoundary/withFaroErrorBoundary.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
function withFaroErrorBoundary(WrappedComponent, errorBoundaryProps) {
  var _a, _b;
  const componentDisplayName = (_b = (_a = WrappedComponent.displayName) !== null && _a !== void 0 ? _a : WrappedComponent.name) !== null && _b !== void 0 ? _b : unknownString;
  const Component3 = (wrappedComponentProps) => (0, import_jsx_runtime.jsx)(FaroErrorBoundary, Object.assign({}, errorBoundaryProps, { children: (0, import_jsx_runtime.jsx)(WrappedComponent, Object.assign({}, wrappedComponentProps)) }));
  Component3.displayName = `faroErrorBoundary(${componentDisplayName})`;
  (0, import_hoist_non_react_statics.default)(Component3, WrappedComponent);
  return Component3;
}

// node_modules/@grafana/faro-react/dist/esm/router/types.js
var ReactRouterVersion;
(function(ReactRouterVersion2) {
  ReactRouterVersion2["V4"] = "v4";
  ReactRouterVersion2["V5"] = "v5";
  ReactRouterVersion2["V6"] = "v6";
  ReactRouterVersion2["V6_data_router"] = "v6_data_router";
})(ReactRouterVersion || (ReactRouterVersion = {}));
var NavigationType;
(function(NavigationType2) {
  NavigationType2["Pop"] = "POP";
  NavigationType2["Push"] = "PUSH";
  NavigationType2["Replace"] = "REPLACE";
})(NavigationType || (NavigationType = {}));

// node_modules/@grafana/faro-react/dist/esm/router/v4v5/FaroRoute.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@grafana/faro-react/dist/esm/router/v4v5/activeEvent.js
var activeEvent = void 0;
function createNewActiveEvent(url) {
  activeEvent = {
    route: "",
    url
  };
  return activeEvent;
}
function setActiveEventRoute(route) {
  if (activeEvent) {
    activeEvent.route = route;
  }
}
function sendActiveEvent() {
  api.pushEvent(EVENT_ROUTE_CHANGE, activeEvent, void 0, { skipDedupe: true });
  activeEvent = void 0;
}

// node_modules/@grafana/faro-react/dist/esm/router/v4v5/routerDependencies.js
var isInitialized = false;
var history;
var Route;
function setReactRouterV4V5Dependencies(dependencies) {
  isInitialized = true;
  history = dependencies.history;
  Route = dependencies.Route;
}
function setReactRouterV4V5SSRDependencies(newDependencies) {
  Route = newDependencies.Route;
}

// node_modules/@grafana/faro-react/dist/esm/router/v4v5/FaroRoute.js
function FaroRoute(props) {
  var _a;
  if ((_a = props === null || props === void 0 ? void 0 : props.computedMatch) === null || _a === void 0 ? void 0 : _a.isExact) {
    setActiveEventRoute(props.computedMatch.path);
  }
  return (0, import_jsx_runtime2.jsx)(Route, Object.assign({}, props));
}

// node_modules/@grafana/faro-react/dist/esm/router/v4v5/initialize.js
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
function initializeReactRouterV4V5Instrumentation(dependencies) {
  var _a, _b, _c, _d;
  const Route2 = dependencies.Route;
  const componentDisplayName = (_a = Route2.displayName) !== null && _a !== void 0 ? _a : Route2.name;
  FaroRoute.displayName = `faroRoute(${componentDisplayName})`;
  (0, import_hoist_non_react_statics2.default)(FaroRoute, Route2);
  setReactRouterV4V5Dependencies(dependencies);
  createNewActiveEvent((_b = globalObject.location) === null || _b === void 0 ? void 0 : _b.href);
  (_d = (_c = dependencies.history).listen) === null || _d === void 0 ? void 0 : _d.call(_c, (_location, action) => {
    var _a2;
    if (action === NavigationType.Push || action === NavigationType.Pop) {
      sendActiveEvent();
      createNewActiveEvent((_a2 = globalObject.location) === null || _a2 === void 0 ? void 0 : _a2.href);
    }
  });
}
function createReactRouterV4Options(dependencies) {
  return {
    version: ReactRouterVersion.V4,
    dependencies
  };
}
function createReactRouterV5Options(dependencies) {
  return {
    version: ReactRouterVersion.V5,
    dependencies
  };
}

// node_modules/@grafana/faro-react/dist/esm/router/v6/FaroRoutes.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());

// node_modules/@grafana/faro-react/dist/esm/router/v6/routerDependencies.js
var isInitialized2 = false;
var createRoutesFromChildren;
var matchRoutes;
var Routes;
var useLocation;
var useNavigationType;
function setReactRouterV6Dependencies(newDependencies) {
  isInitialized2 = true;
  createRoutesFromChildren = newDependencies.createRoutesFromChildren;
  matchRoutes = newDependencies.matchRoutes;
  Routes = newDependencies.Routes;
  useLocation = newDependencies.useLocation;
  useNavigationType = newDependencies.useNavigationType;
}
function setReactRouterV6SSRDependencies(newDependencies) {
  Routes = newDependencies.Routes;
}
function setReactRouterV6DataRouterDependencies(newDependencies) {
  isInitialized2 = true;
  matchRoutes = newDependencies.matchRoutes;
}

// node_modules/@grafana/faro-react/dist/esm/router/v6/utils.js
function getNumberOfUrlSegments(url) {
  return url.split(/\\?\//).filter((currentSegment) => currentSegment.length > 0 && currentSegment !== ",").length;
}
function getRouteFromLocation(routes, location) {
  if (!routes || routes.length === 0) {
    return location.pathname;
  }
  const matchedRoutes = matchRoutes(routes, location);
  let pathBuilder = "";
  if (matchedRoutes) {
    for (let x = 0; x < matchedRoutes.length; x++) {
      const branch = matchedRoutes[x];
      const route = branch.route;
      if (route) {
        if (route.index) {
          return branch.pathname;
        }
        let path = route.path;
        if (path) {
          path = path.startsWith("/") ? path : `/${path}`;
          pathBuilder += path;
          if (branch.pathname === location.pathname) {
            if (getNumberOfUrlSegments(pathBuilder) !== getNumberOfUrlSegments(branch.pathname)) {
              return path;
            }
            return pathBuilder;
          }
        }
      }
    }
  }
  return location.pathname;
}

// node_modules/@grafana/faro-react/dist/esm/router/v6/FaroRoutes.js
function FaroRoutes(props) {
  var _a;
  const location = useLocation === null || useLocation === void 0 ? void 0 : useLocation();
  const navigationType = useNavigationType === null || useNavigationType === void 0 ? void 0 : useNavigationType();
  const routes = (0, import_react3.useMemo)(() => {
    var _a2;
    return (_a2 = createRoutesFromChildren === null || createRoutesFromChildren === void 0 ? void 0 : createRoutesFromChildren(props.children)) !== null && _a2 !== void 0 ? _a2 : [];
  }, [props.children]);
  const lastRouteRef = (0, import_react3.useRef)({});
  (0, import_react3.useEffect)(() => {
    var _a2, _b;
    if (isInitialized2 && (navigationType === NavigationType.Push || navigationType === NavigationType.Pop)) {
      const route = getRouteFromLocation(routes, location);
      const url = (_a2 = globalObject.location) === null || _a2 === void 0 ? void 0 : _a2.href;
      api.pushEvent(EVENT_ROUTE_CHANGE, Object.assign({ toRoute: route, toUrl: (_b = globalObject.location) === null || _b === void 0 ? void 0 : _b.href }, lastRouteRef.current));
      lastRouteRef.current = {
        fromRoute: route,
        fromUrl: url
      };
    }
  }, [location, navigationType, routes]);
  const ActualRoutes = (_a = props.routesComponent) !== null && _a !== void 0 ? _a : Routes;
  return (0, import_jsx_runtime3.jsx)(ActualRoutes, Object.assign({}, props));
}

// node_modules/@grafana/faro-react/dist/esm/router/v6/initialize.js
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs());
function initializeReactRouterV6Instrumentation(dependencies) {
  (0, import_hoist_non_react_statics3.default)(FaroRoutes, dependencies.Routes);
  setReactRouterV6Dependencies(dependencies);
}
function createReactRouterV6Options(dependencies) {
  return {
    version: ReactRouterVersion.V6,
    dependencies
  };
}
function initializeReactRouterV6DataRouterInstrumentation(dependencies) {
  setReactRouterV6DataRouterDependencies(dependencies);
}
function createReactRouterV6DataOptions(dependencies) {
  return {
    version: ReactRouterVersion.V6_data_router,
    dependencies
  };
}

// node_modules/@grafana/faro-react/dist/esm/router/v6/withFaroRouterInstrumentation.js
function withFaroRouterInstrumentation(router) {
  let lastRoute = {};
  router.subscribe((state) => {
    var _a, _b;
    const navigationType = state.historyAction;
    const location = state.location;
    const routes = router.routes;
    if (isInitialized2 && (navigationType === NavigationType.Push || navigationType === NavigationType.Pop)) {
      const route = getRouteFromLocation(routes, location);
      const url = (_a = globalObject.location) === null || _a === void 0 ? void 0 : _a.href;
      api.pushEvent(EVENT_ROUTE_CHANGE, Object.assign({ toRoute: route, toUrl: (_b = globalObject.location) === null || _b === void 0 ? void 0 : _b.href }, lastRoute));
      lastRoute = {
        fromRoute: route,
        fromUrl: url
      };
    }
  });
  return router;
}

// node_modules/@grafana/faro-react/dist/esm/router/initialize.js
function initializeReactRouterInstrumentation(options) {
  var _a;
  const initMessage = "Initializing React Router";
  switch ((_a = options.router) === null || _a === void 0 ? void 0 : _a.version) {
    case ReactRouterVersion.V6:
      internalLogger.debug(`${initMessage} V6 instrumentation`);
      initializeReactRouterV6Instrumentation(options.router.dependencies);
      break;
    case ReactRouterVersion.V6_data_router:
      internalLogger.debug(`${initMessage} V6 data router instrumentation`);
      initializeReactRouterV6DataRouterInstrumentation(options.router.dependencies);
      break;
    case ReactRouterVersion.V5:
    case ReactRouterVersion.V4:
      internalLogger.debug(`${initMessage} ${options.router.version} instrumentation`);
      initializeReactRouterV4V5Instrumentation(options.router.dependencies);
      break;
    default:
      internalLogger.debug("Skipping initialization of React Router instrumentation");
  }
}

// node_modules/@grafana/faro-react/dist/esm/instrumentation.js
var ReactIntegration = class extends BaseInstrumentation {
  constructor(options = {}) {
    super();
    this.options = options;
    this.name = "@grafana/faro-react";
    this.version = VERSION;
  }
  initialize() {
    setDependencies(this.internalLogger, this.api);
    initializeReactRouterInstrumentation(this.options);
  }
};

// node_modules/@grafana/faro-react/dist/esm/profiler/FaroProfiler.js
var import_react4 = __toESM(require_react());
var FaroProfiler = class extends import_react4.Component {
  get isOtelInitialized() {
    return !!(api === null || api === void 0 ? void 0 : api.isOTELInitialized());
  }
  get otel() {
    return api === null || api === void 0 ? void 0 : api.getOTEL();
  }
  get tracer() {
    var _a;
    return (_a = this.otel) === null || _a === void 0 ? void 0 : _a.trace.getTracer("@grafana/faro-react", VERSION);
  }
  createSpan(spanName, options) {
    var _a, _b;
    const span = this.tracer.startSpan(spanName, {
      startTime: options === null || options === void 0 ? void 0 : options.startTime,
      attributes: Object.assign({ "react.component.name": this.props.name }, (_a = options === null || options === void 0 ? void 0 : options.attributes) !== null && _a !== void 0 ? _a : {})
    });
    (_b = this.otel) === null || _b === void 0 ? void 0 : _b.trace.setSpan(this.otel.context.active(), span);
    if (options === null || options === void 0 ? void 0 : options.endTime) {
      span.end(options.endTime);
    }
    return span;
  }
  createChildSpan(spanName, parent, options) {
    var _a;
    let span;
    (_a = this.otel) === null || _a === void 0 ? void 0 : _a.context.with(this.otel.trace.setSpan(this.otel.context.active(), parent), () => {
      span = this.createSpan(spanName, options);
    });
    return span;
  }
  constructor(props) {
    super(props);
    this.mountSpan = void 0;
    this.mountSpanEndTime = void 0;
    this.updateSpan = void 0;
    if (this.isOtelInitialized) {
      this.mountSpan = this.createSpan("componentMount");
    } else {
      internalLogger === null || internalLogger === void 0 ? void 0 : internalLogger.error('The Faro React Profiler requires tracing instrumentation. Please enable it in the "instrumentations" section of your config.');
    }
  }
  componentDidMount() {
    if (this.isOtelInitialized && this.mountSpan) {
      this.mountSpanEndTime = Date.now();
      this.mountSpan.end(this.mountSpanEndTime);
    }
  }
  shouldComponentUpdate({ updateProps }) {
    if (this.isOtelInitialized && this.mountSpan && updateProps !== this.props.updateProps) {
      const changedProps = Object.keys(updateProps).filter((key) => updateProps[key] !== this.props.updateProps[key]);
      if (changedProps.length > 0) {
        this.updateSpan = this.createChildSpan("componentUpdate", this.mountSpan, {
          attributes: {
            "react.component.changed_props": changedProps
          }
        });
      }
    }
    return true;
  }
  componentDidUpdate() {
    if (this.isOtelInitialized && this.updateSpan) {
      this.updateSpan.end();
      this.updateSpan = void 0;
    }
  }
  componentWillUnmount() {
    if (this.isOtelInitialized && this.mountSpan) {
      this.createChildSpan("componentRender", this.mountSpan, {
        startTime: this.mountSpanEndTime,
        endTime: Date.now()
      });
    }
  }
  render() {
    return this.props.children;
  }
};

// node_modules/@grafana/faro-react/dist/esm/profiler/withFaroProfiler.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_hoist_non_react_statics4 = __toESM(require_hoist_non_react_statics_cjs());
function withFaroProfiler(WrappedComponent, options) {
  var _a, _b, _c;
  const componentDisplayName = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : WrappedComponent.displayName) !== null && _b !== void 0 ? _b : WrappedComponent.name) !== null && _c !== void 0 ? _c : unknownString;
  const Component3 = (props) => (0, import_jsx_runtime4.jsx)(FaroProfiler, { name: componentDisplayName, updateProps: props, children: (0, import_jsx_runtime4.jsx)(WrappedComponent, Object.assign({}, props)) });
  Component3.displayName = `faroProfiler(${componentDisplayName})`;
  (0, import_hoist_non_react_statics4.default)(Component3, WrappedComponent);
  return Component3;
}
export {
  BaseExtension,
  BaseInstrumentation,
  BaseTransport,
  ConsoleInstrumentation,
  ConsoleTransport,
  Conventions,
  ErrorsInstrumentation,
  FaroErrorBoundary,
  FaroProfiler,
  FaroRoute,
  FaroRoutes,
  FetchTransport,
  InternalLoggerLevel,
  LogLevel,
  NavigationType,
  ReactIntegration,
  ReactRouterVersion,
  TransportItemType,
  VERSION,
  ViewInstrumentation,
  WebVitalsInstrumentation,
  allLogLevels,
  browserMeta,
  buildStackFrame,
  createInternalLogger,
  createPromiseBuffer,
  createReactRouterV4Options,
  createReactRouterV5Options,
  createReactRouterV6DataOptions,
  createReactRouterV6Options,
  createSession,
  deepEqual,
  defaultEventDomain,
  defaultExceptionType,
  defaultGlobalObjectKey,
  defaultInternalLoggerLevel,
  defaultLogLevel,
  faro,
  faroErrorBoundaryInitialState,
  genShortID,
  getCurrentTimestamp,
  getDataFromSafariExtensions,
  getInternalFromGlobalObject as getInternalFaroFromGlobalObject,
  getMajorReactVersion,
  getStackFramesFromError,
  getTransportBody,
  getWebInstrumentations,
  globalObject,
  initializeFaro,
  internalGlobalObjectKey,
  isArray,
  isBoolean,
  isDomError,
  isDomException,
  isElement,
  isElementDefined,
  isError,
  isErrorDefined,
  isErrorEvent,
  isEvent,
  isEventDefined,
  isFunction,
  isInstanceOf,
  isInt,
  isInternalFaroOnGlobalObject,
  isMap,
  isMapDefined,
  isNull,
  isNumber,
  isObject,
  isPrimitive,
  isReactVersionAtLeast,
  isReactVersionAtLeast16,
  isReactVersionAtLeast17,
  isReactVersionAtLeast18,
  isRegExp,
  isString,
  isSymbol,
  isSyntheticEvent,
  isThenable,
  isToString,
  isTypeof,
  isUndefined,
  makeCoreConfig,
  noop,
  parseStacktrace,
  reactVersion,
  reactVersionMajor,
  setInternalFaroOnGlobalObject,
  setReactRouterV4V5SSRDependencies,
  setReactRouterV6SSRDependencies,
  transportItemTypeToBodyKey,
  userActionDataAttribute,
  withFaroErrorBoundary,
  withFaroProfiler,
  withFaroRouterInstrumentation
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@grafana_faro-react.js.map
