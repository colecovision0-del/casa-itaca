'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var MagicString = require('magic-string');
var faroBundlersShared = require('@grafana/faro-bundlers-shared');
var fs = require('fs');

function faroUploader(pluginOptions) {
  var _a;
  const {
    endpoint,
    appId,
    apiKey,
    stackId,
    appName,
    outputFiles,
    keepSourcemaps,
    gzipContents,
    verbose,
    skipUpload
  } = pluginOptions;
  const bundleId = (_a = pluginOptions.bundleId) !== null && _a !== void 0 ? _a : String(Date.now() + faroBundlersShared.randomString(5));
  const uploadEndpoint = `${endpoint}/app/${appId}/sourcemaps/`;
  const maxSize = pluginOptions.maxUploadSize && pluginOptions.maxUploadSize > 0 ? pluginOptions.maxUploadSize : faroBundlersShared.THIRTY_MB_IN_BYTES;
  // Export bundleId to environment variable if skipUpload is true
  if (skipUpload) {
    faroBundlersShared.exportBundleIdToFile(bundleId, appName, verbose);
  }
  return {
    name: faroBundlersShared.ROLLUP_PLUGIN_NAME,
    /**
     * Renders a chunk of code and generates a source map with a bundleId code snippet injected at the end.
     * @param code The original code of the chunk.
     * @param chunk The chunk object containing information about the file.
     * @returns An object with the rendered code and the generated source map, or null if the chunk's file extension does not match the patterns.
     */
    renderChunk(code, chunk) {
      if (chunk.fileName.match(/\.(js|ts|jsx|tsx|mjs|cjs)$/)) {
        const newCode = new MagicString(code);
        newCode.prepend(faroBundlersShared.faroBundleIdSnippet(bundleId, appName));
        const map = newCode.generateMap({
          source: chunk.fileName,
          file: `${chunk.fileName}.map`
        });
        return {
          code: newCode.toString(),
          map
        };
      }
      return null;
    },
    async writeBundle(options, bundle) {
      // Skip uploading if skipUpload is true
      if (skipUpload) {
        verbose && faroBundlersShared.consoleInfoOrange(`Skipping sourcemap upload as skipUpload is set to true`);
        return;
      }
      const uploadedSourcemaps = [];
      try {
        const outputPath = options.dir;
        const sourcemapEndpoint = uploadEndpoint + bundleId;
        const filesToUpload = [];
        let totalSize = 0;
        for (let filename in bundle) {
          // Only include JavaScript-related source maps or match the outputFiles regex
          if (!faroBundlersShared.shouldProcessFile(filename, outputFiles)) {
            continue;
          }
          // if we are tar/gzipping contents, collect N files and upload them all at once
          // total size of all files uploaded at once must be less than the configured max size (uncompressed)
          if (gzipContents) {
            const file = `${outputPath}/${filename}`;
            const {
              size
            } = fs.statSync(file);
            filesToUpload.push(file);
            totalSize += size;
            if (totalSize > maxSize) {
              filesToUpload.pop();
              const result = await faroBundlersShared.uploadCompressedSourceMaps({
                sourcemapEndpoint,
                apiKey,
                stackId,
                outputPath,
                files: filesToUpload,
                keepSourcemaps: !!keepSourcemaps,
                verbose: verbose
              });
              if (result) {
                uploadedSourcemaps.push(...filesToUpload);
              }
              filesToUpload.length = 0;
              filesToUpload.push(file);
              totalSize = size;
            }
          }
          // if we are not compressing, upload each file individually
          if (!gzipContents) {
            const result = await faroBundlersShared.uploadSourceMap({
              sourcemapEndpoint,
              apiKey,
              stackId,
              filename,
              filePath: `${outputPath}/${filename}`,
              keepSourcemaps: !!keepSourcemaps,
              verbose: verbose
            });
            if (result) {
              uploadedSourcemaps.push(filename);
            }
          }
        }
        // upload any remaining files
        if (filesToUpload.length) {
          const result = await faroBundlersShared.uploadCompressedSourceMaps({
            sourcemapEndpoint,
            apiKey,
            stackId,
            outputPath,
            files: filesToUpload,
            keepSourcemaps: !!keepSourcemaps,
            verbose: verbose
          });
          if (result) {
            uploadedSourcemaps.push(...filesToUpload);
          }
        }
      } catch (e) {
        console.error(e);
      }
      if (verbose) {
        faroBundlersShared.consoleInfoOrange(uploadedSourcemaps.length ? `Uploaded sourcemaps: ${uploadedSourcemaps.map(map => map.split('/').pop()).join(", ")}` : "No sourcemaps uploaded");
      }
    }
  };
}
module.exports = faroUploader;

exports.default = faroUploader;
//# sourceMappingURL=index.js.map
